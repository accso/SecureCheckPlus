"""
This module handles the parsing related to the reports generated by owasp.
"""

import json
import logging
import urllib.parse

from utilities.exceptions import ParseError
from .types import ParseResult

logger = logging.getLogger(__name__)

priority = {"HIGHEST": 4,
            "HIGH": 3,
            "MEDIUM": 2,
            "LOW": 1}


def get_dependency_and_package_manager_name(packages):
  """
  Returns the dependency and package manager name as a tuple.
  """
  try:
    # Detecting the highest priority package
    highest_priority_package = packages[0]
    highest_priority = priority[highest_priority_package["confidence"]]

    for package in packages[1:]:
      package_priority = priority[package["confidence"]]
      if package_priority > highest_priority:
        highest_priority_package = package
        highest_priority = package_priority

    highest_priority_id = urllib.parse.unquote(highest_priority_package["id"])

    # Find the index of the first ":"
    colon_index = highest_priority_id.index(":")

    # Extract dependency_name from the characters after the first ":"
    start_index = colon_index + 1
    slash_index = highest_priority_id.index("/", start_index)
    package_manager = highest_priority_id[start_index:slash_index]

    # Extract package_manager from the characters after the first "/" until the last "@"
    start_index = slash_index + 1
    at_index = highest_priority_id.rindex("@")
    dependency_name = highest_priority_id[start_index:at_index]

    return dependency_name, package_manager
  except Exception as error:
    logger.warning(str(error))
    return "NA", "NA"


def parse_json(json_data: str or dict) -> dict[str, ParseResult]:
  """
    Parses the JSON OWASP report into a standardized dictionary.

    :param json_data: OWASP Dependency-Check report as a JSON string or dictionary.
    :raises ParseError: Raises if an error occurred while trying to parse the report.
    :return: A dictionary with the dependency as the key and an array of detected vulnerabilities as a list.
    """

  try:
    if isinstance(json_data, dict):
      dependencies = json_data["dependencies"]
    else:
      dependencies = json.loads(json_data)["dependencies"]

    data: dict[str, ParseResult] = {}
    for dependency in dependencies:
      if len(dependency.get("packages", [])) > 0:
        evidence = dependency["evidenceCollected"]
        version = "NA"
        highest_version_confidence = 0
        dependency_name, package_manager = get_dependency_and_package_manager_name(
          dependency["packages"])
        group_id = None

        for version_evidence in evidence["versionEvidence"]:
          version_confidence = priority[version_evidence["confidence"]]
          if version_confidence > highest_version_confidence:
            version = version_evidence["value"]

        for product_evidence in evidence["productEvidence"]:
          source = product_evidence["source"]
          if source == "pom":
            if product_evidence["name"] == "groupid":
              group_id = product_evidence["value"]

        if group_id:
          dependency_name = f"{group_id}:{dependency_name}"

        path = dependency["filePath"]
        dependency_license = dependency.get("license", "NA")

        vulnerabilities = [vuln["name"] for vuln in
                           dependency.get("vulnerabilities", []) if
                           vuln["source"] in ["NVD", "OSSINDEX"]]

        result = ParseResult(dependency_name, version, path,
                             dependency_license,
                             vulnerabilities, package_manager)
        data[f"{dependency_name}:{version}"] = result

    return data
  except (KeyError, TypeError, json.decoder.JSONDecodeError) as error:
    error_message = str(error)
    logger.warning(f"Error while parsing JSON file: {error_message}")
    raise ParseError(f"Error while parsing JSON file: {error_message}")
